<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>楽器練習ゲーム</title>
  <style>
    canvas {
      border: 1px solid black;
      background-color: #fff;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <h1 style="text-align: center;">楽器練習ゲーム</h1>
  <div style="text-align: center;">
    <button id="startButton">開始</button>
    <button id="toggleMetronome">メトロノーム オン/オフ</button>
    <label>BPM: <input type="number" id="bpmInput" value="120" min="30" max="300" /></label>
  </div>
  <canvas id="sheet" width="1000" height="600"></canvas>

  <script>
    const startButton = document.getElementById('startButton');
    const toggleMetronomeButton = document.getElementById('toggleMetronome');
    const bpmInput = document.getElementById('bpmInput');
    const canvas = document.getElementById('sheet');
    const ctx = canvas.getContext('2d');

    let audioContext;
    let analyser;
    let buffer;
    let source;
    let oscillator;
    let metronomeInterval = null;
    let metronomeOn = true;
    let time = 0;
    const noteHistory = [];

    startButton.onclick = async () => {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      source = audioContext.createMediaStreamSource(stream);
      analyser = audioContext.createAnalyser();
      analyser.fftSize = 32768;
      buffer = new Float32Array(analyser.fftSize);
      source.connect(analyser);

      updateMetronome();
      draw();
    };

    toggleMetronomeButton.onclick = () => {
      metronomeOn = !metronomeOn;
      updateMetronome();
    };

    bpmInput.onchange = () => {
      updateMetronome();
    };

    function updateMetronome() {
      if (metronomeInterval) {
        clearInterval(metronomeInterval);
        metronomeInterval = null;
      }

      const BPM = parseInt(bpmInput.value, 10);
      const intervalMs = 60000 / BPM;

      if (metronomeOn) {
        metronomeInterval = setInterval(() => {
          oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          oscillator.type = 'square';
          oscillator.frequency.setValueAtTime(1000, audioContext.currentTime);
          gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
          oscillator.connect(gainNode).connect(audioContext.destination);
          oscillator.start();
          oscillator.stop(audioContext.currentTime + 0.05);
          time++;
        }, intervalMs);
      }
    }

    function draw() {
      requestAnimationFrame(draw);

      analyser.getFloatTimeDomainData(buffer);
      const pitch = detectPitch(buffer, audioContext.sampleRate);
      const color = pitchToColor(pitch);
      const y = pitchToY(pitch);
      const volume = calculateVolume(buffer);

      if (pitch > 0 && volume > 0.002) {
        noteHistory.push({
          time: performance.now(),
          pitch: pitch,
          y: y,
          color: color,
          strength: volume,
        });
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMetronomeLines();
      drawStaffLines();
      drawClefs();

      const now = performance.now();
      const scrollSpeed = canvas.width / (4 * 1000);

      noteHistory.forEach(note => {
        const x = canvas.width - (now - note.time) * scrollSpeed;
        const width = 10;
        const height = note.strength * 100;
        ctx.fillStyle = note.color;
        ctx.fillRect(x, note.y - height / 2, width, height);
      });
    }

    function drawMetronomeLines() {
      const BPM = parseInt(bpmInput.value, 10);
      const intervalMs = 60000 / BPM;
      const now = performance.now();
      const scrollSpeed = canvas.width / (4 * 1000);
      for (let i = -10; i < 100; i++) {
        const metronomeTime = now - (now % intervalMs) - i * intervalMs;
        const x = canvas.width - (now - metronomeTime) * scrollSpeed;
        if (x >= 0 && x <= canvas.width) {
          ctx.strokeStyle = '#ccc';
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
      }
    }

    function drawStaffLines() {
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      const bassStaff = [87.31, 110.00, 130.81, 164.81, 196.00];
      const trebleStaff = [329.63, 392.00, 493.88, 587.33, 698.46];

      [...bassStaff, ...trebleStaff].forEach(freq => {
        const y = pitchToY(freq);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      });
    }

    function drawClefs() {
      ctx.fillStyle = '#000';
      ctx.font = '48px serif';
      const trebleY = pitchToY(392.00) + 12;
      const bassY = pitchToY(130.81) + 16;
      ctx.fillText('\uD834\uDD1E', 10, trebleY);
      ctx.fillText('\uD834\uDD22', 10, bassY);
    }

    function detectPitch(buffer, sampleRate) {
      let bestOffset = -1;
      let bestCorrelation = 0;
      const SIZE = buffer.length;
      for (let offset = 16; offset < SIZE / 2; offset++) {
        let correlation = 0;
        for (let i = 0; i < SIZE - offset; i++) {
          correlation += buffer[i] * buffer[i + offset];
        }
        if (correlation > bestCorrelation) {
          bestCorrelation = correlation;
          bestOffset = offset;
        }
      }
      if (bestCorrelation > 0.002) {
        return sampleRate / bestOffset;
      }
      return 0;
    }

    function pitchToColor(pitch) {
      if (pitch === 0) return 'gray';
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const synestheticColors = {
        'C': '#FF0000', 'C#': '#FF8000', 'D': '#FFFF00', 'D#': '#80FF00', 'E': '#00FF00',
        'F': '#00FFFF', 'F#': '#0080FF', 'G': '#0000FF', 'G#': '#8000FF', 'A': '#FF00FF',
        'A#': '#FF0080', 'B': '#804000'
      };
      const midiNote = Math.round(12 * Math.log2(pitch / 440) + 69);
      const noteName = noteNames[(midiNote % 12 + 12) % 12];
      return synestheticColors[noteName] || 'black';
    }

    function pitchToY(pitch) {
      const minPitch = 27.5;
      const maxPitch = 4186;
      const logMin = Math.log2(minPitch);
      const logMax = Math.log2(maxPitch);
      const logPitch = Math.log2(pitch);
      return canvas.height - ((logPitch - logMin) / (logMax - logMin)) * canvas.height;
    }

    function calculateVolume(buffer) {
      let sum = 0;
      for (let i = 0; i < buffer.length; i++) {
        sum += buffer[i] * buffer[i];
      }
      return Math.sqrt(sum / buffer.length);
    }
  </script>
</body>
</html>
